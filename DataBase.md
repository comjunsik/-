# Mysql을 사용한 이유
**장점**
- 안정성, 많이 쓰고 잇기 때문에 믿을 수 있다.
- 배우고 운영하기 쉽다, 구조가 간단하기 때문에 빠르다.
- 각격이 싸다.
- 지원이 잘 된다.
- 유연하고 확장이 가능한 구조이다.

**단점**
+ GPL의 구속을 벗어나려면 상용 버전을 구매해야 한다.
+ 이미 다른 DB를 사용하고 있는 경우에는 mysql로 옮겨가기 어렵다.
+ Oracle은 30년째 개발되고 잇는데 mysql은 아직 어리다.
+ 새로 추가되기 시작한 기능들은 아직 충분히 안정화되지 않았다.
+ 인증된 개발자/운영자나 공인 파트너사가 부족하다.
+ mysql은 Oracle이나 MS에 비해 규모가 작아 신뢰하기 어렵다


# DataBase에서 Index란?
Table에 대한 동작 속도를 높여주는 자료구조로서 빠른 검색을 가능하게 해준다.

+ 인덱스는 데이터베이스 분야에 있어서 **테이블에 대한 동작의 속도를 높여주는 자료 구조** fmf dlfzjesmsek.
+ 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다.
+ 고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효울적인 순서 매김 동작에 대한 기초를 제공한다.
+ 인덱스를 저자하는 데 필요한 디스크 공간은 보통 테이블을 저장하는 데 필요한 디스크 공간보다 작다.
<br><br>
+ 데이터베이스에서 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하고 있는 객체(object)이다.
+ 사용자는 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 인덱스를 생성하고 사용한다.

**DB에서 자료를 검색하는 두 가지 방법** <br>
+ **FTS**(Full Table Scan) : 테이블을 처음 부터 끝까지 검색하는 방법
+ **Index Scan** : 인덱스를 검색하여 해당 자료의 테이블을 액세스 하는 방법.

# 트랜잭션(Transaction)
예를 들어 A계좌에서 B계좌로 일정 금액을 이체한다고 할때. 이를 위해서는 A계좌의 잔액을 확인하고 현재 금액에서 인출할 금액을 뺀 나머지 금액을 다시 저장합니다. 그런 다음 B계좌의 잔액 읽어 들인 후 이체된 금액을 더하고 그 합을 다시 저장하면 계좌 이체가 완료됩니다.
이러한 과정들이 모두 합쳐져 계좌이체라는 하나의 작업단위를 구성합니다.
데이터베이스에서는 이와 같은 **하나의 논리적인 작업 단위를 구성하는 연산들의 집합을 트랜잭션**이라고 합니다.
이러한 관점에서 **데이터베이스 응용 프로그램은 트랜잭션들의 집합으로 저으이 할 수 있습니다.** <br>
![image](https://user-images.githubusercontent.com/41488792/47812984-1c510880-dd8d-11e8-9936-129c05609d32.png)

![image](https://user-images.githubusercontent.com/41488792/47813174-a00af500-dd8d-11e8-9016-e40cb3d1737a.png)
![image](https://user-images.githubusercontent.com/41488792/47813335-20c9f100-dd8e-11e8-9c6e-d0cd1f9cdf79.png)

# DB 프로시저(Stored Procedure)
데이타 베이스에서 프로시저란 보통 저장 프로시저(stored procedure)
를 말합니다.

그것은 원론적으로 말해서 일반 함수가 하는것과 거의 비슷한 일을 하고
개념도 비슷합니다. 다만 그것은 DB서버측에 위치한다는 것입니다.

DB 서버측에 만들어 두는 함수 정도로 이해하시면 되겠습니다.
(* 리턴값을 넘겨주는 방식에서 함수와는 약간의 차이가 있습니다.)

여기서 중요한 것은 프로시져는 서버측(Server side)에 탑재된다는 것입니다.
그렇다면 클라이언트에서 그냥 함수 만들어서 쓸것이지, 왜 골아프게 저장 프로시져
같은걸 만들어서 DB서버측에 넣어놓나? 하실겁니다.

그 이유는.. DB 서버측에 저장 프로시져로 넣어놓으면 일관성있고.. 관리가 쉬워지며
유지보수가 용이하다는 장점이 있기 때문입니다.
프로시져를 애용하는 어떤 프로그래머들은 대부분의 기능을 클라이언트 어플리케이션에
구현하지 않고 DB서버에다가 프로시져로 만들어놓고 사용한다는(?) 괴설도 들어본적이
있습니다. ㅡ_ㅡ;;

예를들어 사용자가 100만명으로 운용되는 시스템이 있는데, 어떤 기능을 변경해야 한다면...
각 어플리케이션이 새로 접속할때마다 업그레이드를 해주거나 업그레이드 패치를
100만명에게 새로 배포해야 할 것입니다.

그러나 변경해야 할 기능을 프로시져로 만들어 두었다면 DB서버에서 해당 프로시져를
한번 수정해 주는것으로 수정사항이 즉시 모든 사용자들에게 반영이 됩니다.

# DB 트리거(Trigger)
트리거(trigger)는 자기가 종속된 특정 테이블에서 데이터의 변화가 발생했을 때 자동으로 INSERT, UPDATE, DELETE문이 자동으로 실행되는 아주 특별한 종류의 스토어드 프로시저이다.
◈ 트리거는 자기가 종속된 특정 테이블에서 데이터의 변화가 발생했을때 자동으로 생행되는 아주 특별한 종류의 stored procedure이다.

원래 트리거는 총에서 방아쇠를 의미한다. 하지만 RDBMS에서 트리거는 방아쇠를 당기면 총알이 나가듯이, 어떤 테이블의 데이터가 INSERT, UPDATE 또는 DELETE 문을 만나 변화가 생길때 자동으로 실행되게끔 정의해 놓은 Transact-SQL 문들의 집합이라고 볼수있다. 



출처: http://computtee.tistory.

# 제약조건(Constraint)
![image](https://user-images.githubusercontent.com/41488792/47814207-625b9b80-dd90-11e8-984e-ec8439ede961.png)

# 클러스터 인덱스 vs 넌 클러스터 인덱스
![image](https://user-images.githubusercontent.com/41488792/47814554-5ae8c200-dd91-11e8-9b90-5cd5b3a15969.png)

https://lng1982.tistory.com/144
나중에 자세히 보도록 하자 ㅠ
