# JAVA

+ **자바의 특징**에 대해
    + OOP(객체 지향 언어)<br>
    : 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해 전체 프로그램을 완성하는 개발 기법
    **캡슐화, 상속, 다형성**<br>
    + "가비지 컬렉션"에 의한 메모리 자동 관리
        - 가비지(Garbage)란?
        **'정리되지 않은 메로리'** , **유효하지 않은 메모리 주소**를 말한다.
        **주소를 잃어 버려서 사용할 수 없는 메모리**가 바로 '정리되지 않은 메모리' 즉 가비지다.
        프로그래밍 언어로는 **"Dangling Object"** 라고 하고,
        자바에스는 **"가비지(Garbage)"** 라고 부른다.

        - 가비지 컬렉터(Garbage Collector)란?
        **가비지 컬렉터**는 메로리가 부족할 때 **"쓰레기(가비지)"** 를 정리해주는 프로그램을 말한다.
        프로그램을 실행하다 보면 가비지가 발생하게 되는데, 이놈들은 유요한 메모리가 아니다. 그렇게 되면 정리되지 않은 채로 남겨져있는 메모리들은 사용되지도 않으면서 자리를 차지하고 있게된다.
        때문에 JVM의 가비지 컬렉터는 가비지를 다른 용도로 사용할 수 있게 **메모리 해제** 를 시키는 프로그램이다.
    
    + "멀티 쓰레드"를 지원한다.
    ![image](https://user-images.githubusercontent.com/41488792/47766306-63011d00-dd11-11e8-8476-d2b31a1364f4.png)
    정의 : 하나의 프로그램에 동시에 여러개의 일을 수행할수 있도록 해주는 것.
        - **쓰레드란?** <br>
        **동시에 여러가지 작업을 동시에 수행할 수 있게 하는 것**<br>
        1. MP3를 들으며 워드를 작성하면서 인터넷 서핑을 할 수 있다. 이ㅐ 각각의 응용 프로그램은 하나의 프로세스를 갖는다
        2. 반면에 쓰레드는 프로세스를 여러 개로 나눈 조각과 갖다고 설명할 수 있다.
        즉, 워드라는 큰 프로세스 하나에 여러 개의 쓰레드가 모여 있는 것이다.
        3. 프로세스는 쓰레드에 대한 일종의 컨테이너 역할을 한다.
        4. 쓰레드를 이용하면 하나의 프로그램에서 한 번에 하나의 일을 처리하는 것이 아니라 동시에 많은 일을 처리할 수 있다.
        5. 많은 동시 사용자를 처리하는 환경이나 한 번에 많은 작업을 처리하는 응용 프로그램에서 그 위력을 발휘할 것이다.

    
    
    보통 서버 프로그램에서 서버를 띄우게 되면
    이때 서버는 한명의 클라이언트가 들어오면, 하나의 쓰레드를 생성하여 그 쪽에서 클라이언트를 담당하도록 시킵니다. 왜냐하면 서버는 다시 다른 클라이언트가 들어오는 것을 기다려야 하기 때문에,
    그리고 다른 사용자가 또 들어오게 되면 하나의 쓰레드를 생성하여 그쪽으로 보내게 됩니다.
    예를들어, 캐리어와 인터셉터들의 관계.

    + **프로세스(PROCESS) 와 쓰레드(Thread)의 차이점**
        + 프로세스
            : OS가 메모리 등의 자원을 할당해준 <u>실행중인 프로그램</u>을 가리킨다.
            이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에
            서로 메모리 공간을 공유하지 못한다. 따라서 공유하기 위해서는 IPC(InerProcess Communication)과 같은 방식이 필요하다.
        + 쓰레드
            : 프로세스내에서 **동시에 실행되는 독립적인 실행 단위** <br> 
            쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메로리를 갖고 그 외의
            자원(메모리)은 프로세스 내에서 공유하게 된다.
            + Thread의 단점
            **교착상태** 에 빠질 수 있다.
            * 교착상태 : 다중프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행 할 수 없는 어떤 특정시간ㅇ르 기다리고 있는 상태.

    + JVM 위에서 동작하기 때문에 특정 OS에 족송적이지 않고 이식성이 좋으며, 보안성이 좋다.
    JVM만 설치하면 컴ㅍ터의 운영체제에 상관없이 작동
    (**운영체제에 독립적**)<br>
        - **JVM(JAVA Virtual Machine)** 자바 가상 머신. (*가상머신이란 프로그램을 실행하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것이다.*) <br>
        JVM 역할은 자바 애플리케이션을 크래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것이다.
        그리고 JVM은 JAVA와 OS 사이에서 **중개자 역할**을 수행하여 JAVA가 OS에 구애받지 않고 재사용을 가능하게 해준다.
        **메로리 관리**, **GC(Garbage Collection)**을 수행한다.
        <br>**왜 자바 가상머신을 알아야 하는가?** <br>
        한정된 메모릴르 효율적으로 사용하여 최고의 성능을 내기 위해서.
        <br>
        **자바프로그램 실행과정** <br>
        1. 프로그램이 실행되면 JVM은 OS로 부터 이 프로그램이 필요로 하는 메모리를 할당받는다.
        JVM은 이 메로리를 용도에 따라 여러 영역으로 나누어 관리한다.
        2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환시킨다.
        3. Class Loader를 통해 class파일들을 JVM으로 로딩한다.
        4. 로딩된 class파일들은 Exectuion engine을 통해 해석된다.
        5. 해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어지게 된다.
        **이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchroiztion과 GC같은 관리작업을 수행한다.** <br> 
        ![image](https://user-images.githubusercontent.com/41488792/47767168-c12fff00-dd15-11e8-982a-8cc5794cdf17.png)
    + 다양한 Open 라이브러리들이 존재한다.

+ **자바를 만든 사람**은?
    : 제임스 고슬링

+ **변수**란?
    : 하나의 값을 저장할 수 있는 메모리 공간

+ **객체와 클래스**의 차이점
    + **클래스(Class)**<br>
    : 현실 세계의 객체의 속성과 동작을 추려내 필드와 메서드로 정의한 것
    <u>"아직 메로리가 할당되지 않은 상태"</u>

    + **객체(Object)**<br>
    : 이 Class라는 설계도를 기반으로 <u>실제 메모리가 잡힌 것</u>을 의미하며 이런 객체를 조합해 전체 프로그램을 완성해 나가는 방식을 **OOP(객체지향 프로그래밍)** 이라고 한다.
    같은 성질, 같은 구조와 형태를 가지는 객체는 등급으로 정의하고
    등급에 속하는 객체는 그 등급의 인스턴스라고 한다.

+ **객체 지향**의 정의와 특징
    + 정의 : OOP(Object-Oriented Programming) 
    현실세계의 객체들을 필드와 메서드로 정의한 Class를 기반으로 실제 메로리가 잡혀 만들어진 부품과 같은 객체들을 조합해 전체 프로그램을 완성해 나가는 개발 기법
    a. **코드의 재사용성**이 높다
    b. 코드의 변경이 용이
    c. 직관적인 코드 분석
    d. 개발속도 향상
    e. 상속을 통한 장점 극대화

    + 특징
        - **캡슐화, 은닉화** : 외부 객체에서 구현방식은 알 수 없도록 숨기고 별도로 접근할 수 잇는 getter/setter 메서드를 통해 접근하도록 하는 방식

        - **상속** : 부모 Class를 자식이 접근할 수 있도록 물려 받는 방식

        - **다형성** : 부모 클래스 타입으로 해당 부모를 상속받는 여러 자식 class를 대입할 수 있는 성질
        오버로딩, 오버라이드
        >> 서로 다른 클래스로부터 만들어진 객체지만 같은 부모의 Class 타입으로 이들을 관리할 수 있는 성질

        버튼 이라는 것으로 세탁기 버튼, 리모컨 버튼 이런식으로

+ **자바의 메모리** 영역
    1. 메서드 영역
        static 변수, 전역변수, 코드에서 사용되는 class 정보 등이 들어있다.
        코드에서 사용되는 class들을 로더로 읽어 클래스 별로 런타임 필드 데이터, 메서드 데이터 등을 분류해 저장한다.
    2. 스택(Stack)
        지역변수, 함수(메서드) 등이 할당되는
        LIFO(Last In First Out) 방식의 메모리
    3. 힙(HeeP)
        new 연산자를 통한 동적할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메로기가 관리된다.

# 추상메서드? 추상 클래스?

+ 추상메서드
    : 메서드의 정의부만 있고 구현부는 있지 않은 메서드
+ 추상 클래스
    : 추상메서드를 적어도 하나 이상 가지고 있는 클래스로 자식클래스에서  **오버라이딩(재정의)** 가 필요한 추상메서드를 가지고 있기 때문에 <u>객체화 할수 없다.</u>

# 오버로딩과 오버라디잉의 차이
+ 오버로딩(Overloading)
    : 메서드 명은 동일하지만, 매개 변수 타입과 개수를 다르게 해 선언하는 방식
    - 같은 이름의 메소드를 여러개 정의할 수 있다.
    - 매개변수 타입이 다르거나 개수가 달라야 한다.
    - return type과 접근 제어자는 영향을 주지 않는다.
+ 오버라이딩
    : **상속**한 자식에서 부모의 메서드를 재정의 하는 방식

# 자바의 제네릭이란?
: 클래스 내부에서 사용할 데이터 타입을 인스턴스(객체) 생성시에 결정짓는 방식
클래스에서 사용할 타입을 클래스 외부에서 설정하는 것
**클래스<사용할 타입>** <br>
사용 이유: 타입을 잘못 사용하여 발생하는 에러를 최소화
**참조형 데이터 타입**만 설정 가능 하다.
즉, int, char, float, double 과 같은 기본형 데이터 타입은 설정 x
Integer, String 과 같은 **래퍼클래스 (wrapper class)** 형태만 가능
![image](https://user-images.githubusercontent.com/41488792/47771989-9a2ef880-dd28-11e8-8eea-376c5a5ff3b0.png)

Wrapper Class 사용이유
: 기본 data 타입은 객체가 아니어서 Objcet로 받는 다형성을 지원할 수가 없다.
하지만, 메서드에서 실재로 기본데이터 타입을 다형성으로 넘겨주어야 하는 경우가 빈번히 발생하는데,
이때 기본 데이터 타입을 객체로 변환시켜 전달하기 위해 사용된다.
최근에는 AUTO Boxing, AUTO UnBoxing이 지원된다.

# Primitive type 과 Reference type
+ 기본형 데이터 타입(Primitive type)
    + 변수에 값 자체를 저장
    + 정수형 : byte, shor, int, long
    + 실수형 : float, double
    + 문자형 : char
    + 논리형 : boolean
Primitive type은 Wrapper Class를 통해 객체로 변형할 수 있다.
+ Reference type
    + 메모리상에 객체가 있는 위치를 저장
    + 종류 : Class, Interface, Arrary 등
# 인터페이스(interface)란?
: 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로 저장이가 된다.
또한 변수도 자동으로 final stactic 키워드가 붙게 된다.

**왜 인터페이스를 사용하는가?** <br>
+ 팀 작업 시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데,
이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이이스의 메서드 명만 알고 있으면 되기 때문이다. 
이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의 작업을 기다리고 있지 않아도 되며, 
또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.
또한, 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collection.sort()를 하기 위해서 Comparable 인터페이스를 상속하는 것,
Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다.

# Interface, Abstract
+ **Interface** <br>
    + 일종의 추상 클래스
    + 오직 추상메서드와 상수만을 멤버로 갖는다.
    + Implements 키워드를 사용
    + 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.
    + Extends는 하나의 클래스만 상속 가능하나 Interfacs는 **다중 상속이 가능**하다.
+ **Abstract** <br>
    +추상메서드를 하나 이상 가진 클래스
    + 자신의 생성자로 객체 생성 불가능
    + 하위 클래스를 참조하여 상위 클래스의 객체를 생성
    + 하위 클래스를 제어하기 위해 사용
+ **Interface vs Abstract** <br>
     **공통점** <br>
    + new 연산자로 인스턴스 생성 불가능
    + 프로토타입만 있는 메서드를 갖는다
    + 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.
    
    **차이점** <br>
    + 사용하는 키워드가 다르다.
    + Abstract는 일반 메서드를 사용할 수 있찌만, Interface는 메서드 선언만 가능하다.

# Framework
+ 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스프레임과 인터페이스 프레임의 집합
+ 특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업시간을 줄여주는 것이다. 
+ 프레임워크는 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성된다.
+ 프레임워크는 이렇게 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.
+ 프레임워크 컴포넌트 들은 재사용이 가능하다.
+ 프레임워크는 좀 더 높은 수준에서 패턴을 조작한다.

**프레임워크가 중요한 이유** <br>
객체지향 개발을 하게 되면서 개발자의 취향에 따라 다양한 프로그램이 나오게 되었다.
 프로그램 개발에 투입되는 개발자도 점점 늘어남에 따라 전체 시스템의 통합성, 일관성이 부족하게 되었기 때문이다. 
 그래서 개발자의 자유를 제한하기 위해 프레임워크를 도입했다.

**프레임워크가 가져야할 특징** <br>
a. 개발자들이 따라야할 가이드라인을 가지다
b. 개발할 수 있는 범위가 정해져 있다.
c. 개발자를 위한 다양한 도구들이 지원된다.

**프레임워크의 장/단점** <br>
+ 장점 : 개발 시간을 줄일 수 잇꼬 오류로부터 자유로울 수 있다.
+ 단점 : 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해지는 점이다.


# 컬렉션 프레임 워크(CollectionFramework)
+ Collection 인터페이스
+ List 인터페이스
    : 배열과 유사하되, 추가할대마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.

    + ArrayList : 배열로 구현 되었으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다
     하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를 옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.

     + LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만 연결하면 되기 때문에 삽입, 삭제에 유리하다.

     + Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리
     Synchronized(동기화)가 걸려있어 여러 쓰레드에서 동시에 접근할 수 없다.
+ Set 인터페이스
    : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다.
    또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우
    Objcet 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.
     + HashSet
     + TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어졌다. 순서에 맞게 정렬되어 저장되기 위해서 comparable을 구현해야한다.
+ Map 인터페이스
    :key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.
    + HashMap
    + TreeMap
    + Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.
    + Hashtable : HashMap과 구조는 같으며, 단지 Synchroized(동기화) 되어져 있다는 점이 다른점이다.

# private, protected, public, default 제어자
+ private : 같은 class 내부에서만 접근이 가능
+ public : 어디에서든 자유롭게 접근이 가능
+ protected : 같은 class 내부 + 상속받은 자식에서는 부모 class에 접근이 가능
+ default : 아무 것도 선언하지 않은 경우로 같은 패키지 내부에서만 접근이 가능

# Call by Reference, Call by Value
+ Call by reference
    : 매개 변수의 원래 주소에 값을 저장하는 방식, 클래스 인수로 전달한 경우
+ Call by Balue
    : 인수로 기본 데이터형을 사용. 주어진 값을 복사하여 처리하는 방식.
    메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않는다.

# Static의 의미
+ 클래스가 로딩될 때, 메모리 공간을 할당하는데 처음 설정된 메모리 공간이 변하지 않음을 의미
+ 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(**객체와 무관한 키워드**)
